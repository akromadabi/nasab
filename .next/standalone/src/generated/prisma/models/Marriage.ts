
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `Marriage` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model Marriage
 * 
 */
export type MarriageModel = runtime.Types.Result.DefaultSelection<Prisma.$MarriagePayload>

export type AggregateMarriage = {
  _count: MarriageCountAggregateOutputType | null
  _avg: MarriageAvgAggregateOutputType | null
  _sum: MarriageSumAggregateOutputType | null
  _min: MarriageMinAggregateOutputType | null
  _max: MarriageMaxAggregateOutputType | null
}

export type MarriageAvgAggregateOutputType = {
  marriageOrder: number | null
}

export type MarriageSumAggregateOutputType = {
  marriageOrder: number | null
}

export type MarriageMinAggregateOutputType = {
  id: string | null
  husbandId: string | null
  wifeId: string | null
  marriageDate: Date | null
  divorceDate: Date | null
  isActive: boolean | null
  marriageOrder: number | null
  createdAt: Date | null
}

export type MarriageMaxAggregateOutputType = {
  id: string | null
  husbandId: string | null
  wifeId: string | null
  marriageDate: Date | null
  divorceDate: Date | null
  isActive: boolean | null
  marriageOrder: number | null
  createdAt: Date | null
}

export type MarriageCountAggregateOutputType = {
  id: number
  husbandId: number
  wifeId: number
  marriageDate: number
  divorceDate: number
  isActive: number
  marriageOrder: number
  createdAt: number
  _all: number
}


export type MarriageAvgAggregateInputType = {
  marriageOrder?: true
}

export type MarriageSumAggregateInputType = {
  marriageOrder?: true
}

export type MarriageMinAggregateInputType = {
  id?: true
  husbandId?: true
  wifeId?: true
  marriageDate?: true
  divorceDate?: true
  isActive?: true
  marriageOrder?: true
  createdAt?: true
}

export type MarriageMaxAggregateInputType = {
  id?: true
  husbandId?: true
  wifeId?: true
  marriageDate?: true
  divorceDate?: true
  isActive?: true
  marriageOrder?: true
  createdAt?: true
}

export type MarriageCountAggregateInputType = {
  id?: true
  husbandId?: true
  wifeId?: true
  marriageDate?: true
  divorceDate?: true
  isActive?: true
  marriageOrder?: true
  createdAt?: true
  _all?: true
}

export type MarriageAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Marriage to aggregate.
   */
  where?: Prisma.MarriageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Marriages to fetch.
   */
  orderBy?: Prisma.MarriageOrderByWithRelationInput | Prisma.MarriageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.MarriageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Marriages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Marriages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned Marriages
  **/
  _count?: true | MarriageCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to average
  **/
  _avg?: MarriageAvgAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to sum
  **/
  _sum?: MarriageSumAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: MarriageMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: MarriageMaxAggregateInputType
}

export type GetMarriageAggregateType<T extends MarriageAggregateArgs> = {
      [P in keyof T & keyof AggregateMarriage]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateMarriage[P]>
    : Prisma.GetScalarType<T[P], AggregateMarriage[P]>
}




export type MarriageGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.MarriageWhereInput
  orderBy?: Prisma.MarriageOrderByWithAggregationInput | Prisma.MarriageOrderByWithAggregationInput[]
  by: Prisma.MarriageScalarFieldEnum[] | Prisma.MarriageScalarFieldEnum
  having?: Prisma.MarriageScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: MarriageCountAggregateInputType | true
  _avg?: MarriageAvgAggregateInputType
  _sum?: MarriageSumAggregateInputType
  _min?: MarriageMinAggregateInputType
  _max?: MarriageMaxAggregateInputType
}

export type MarriageGroupByOutputType = {
  id: string
  husbandId: string
  wifeId: string
  marriageDate: Date | null
  divorceDate: Date | null
  isActive: boolean
  marriageOrder: number
  createdAt: Date
  _count: MarriageCountAggregateOutputType | null
  _avg: MarriageAvgAggregateOutputType | null
  _sum: MarriageSumAggregateOutputType | null
  _min: MarriageMinAggregateOutputType | null
  _max: MarriageMaxAggregateOutputType | null
}

type GetMarriageGroupByPayload<T extends MarriageGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<MarriageGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof MarriageGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], MarriageGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], MarriageGroupByOutputType[P]>
      }
    >
  >



export type MarriageWhereInput = {
  AND?: Prisma.MarriageWhereInput | Prisma.MarriageWhereInput[]
  OR?: Prisma.MarriageWhereInput[]
  NOT?: Prisma.MarriageWhereInput | Prisma.MarriageWhereInput[]
  id?: Prisma.StringFilter<"Marriage"> | string
  husbandId?: Prisma.StringFilter<"Marriage"> | string
  wifeId?: Prisma.StringFilter<"Marriage"> | string
  marriageDate?: Prisma.DateTimeNullableFilter<"Marriage"> | Date | string | null
  divorceDate?: Prisma.DateTimeNullableFilter<"Marriage"> | Date | string | null
  isActive?: Prisma.BoolFilter<"Marriage"> | boolean
  marriageOrder?: Prisma.IntFilter<"Marriage"> | number
  createdAt?: Prisma.DateTimeFilter<"Marriage"> | Date | string
  husband?: Prisma.XOR<Prisma.MemberScalarRelationFilter, Prisma.MemberWhereInput>
  wife?: Prisma.XOR<Prisma.MemberScalarRelationFilter, Prisma.MemberWhereInput>
}

export type MarriageOrderByWithRelationInput = {
  id?: Prisma.SortOrder
  husbandId?: Prisma.SortOrder
  wifeId?: Prisma.SortOrder
  marriageDate?: Prisma.SortOrderInput | Prisma.SortOrder
  divorceDate?: Prisma.SortOrderInput | Prisma.SortOrder
  isActive?: Prisma.SortOrder
  marriageOrder?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  husband?: Prisma.MemberOrderByWithRelationInput
  wife?: Prisma.MemberOrderByWithRelationInput
  _relevance?: Prisma.MarriageOrderByRelevanceInput
}

export type MarriageWhereUniqueInput = Prisma.AtLeast<{
  id?: string
  AND?: Prisma.MarriageWhereInput | Prisma.MarriageWhereInput[]
  OR?: Prisma.MarriageWhereInput[]
  NOT?: Prisma.MarriageWhereInput | Prisma.MarriageWhereInput[]
  husbandId?: Prisma.StringFilter<"Marriage"> | string
  wifeId?: Prisma.StringFilter<"Marriage"> | string
  marriageDate?: Prisma.DateTimeNullableFilter<"Marriage"> | Date | string | null
  divorceDate?: Prisma.DateTimeNullableFilter<"Marriage"> | Date | string | null
  isActive?: Prisma.BoolFilter<"Marriage"> | boolean
  marriageOrder?: Prisma.IntFilter<"Marriage"> | number
  createdAt?: Prisma.DateTimeFilter<"Marriage"> | Date | string
  husband?: Prisma.XOR<Prisma.MemberScalarRelationFilter, Prisma.MemberWhereInput>
  wife?: Prisma.XOR<Prisma.MemberScalarRelationFilter, Prisma.MemberWhereInput>
}, "id">

export type MarriageOrderByWithAggregationInput = {
  id?: Prisma.SortOrder
  husbandId?: Prisma.SortOrder
  wifeId?: Prisma.SortOrder
  marriageDate?: Prisma.SortOrderInput | Prisma.SortOrder
  divorceDate?: Prisma.SortOrderInput | Prisma.SortOrder
  isActive?: Prisma.SortOrder
  marriageOrder?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
  _count?: Prisma.MarriageCountOrderByAggregateInput
  _avg?: Prisma.MarriageAvgOrderByAggregateInput
  _max?: Prisma.MarriageMaxOrderByAggregateInput
  _min?: Prisma.MarriageMinOrderByAggregateInput
  _sum?: Prisma.MarriageSumOrderByAggregateInput
}

export type MarriageScalarWhereWithAggregatesInput = {
  AND?: Prisma.MarriageScalarWhereWithAggregatesInput | Prisma.MarriageScalarWhereWithAggregatesInput[]
  OR?: Prisma.MarriageScalarWhereWithAggregatesInput[]
  NOT?: Prisma.MarriageScalarWhereWithAggregatesInput | Prisma.MarriageScalarWhereWithAggregatesInput[]
  id?: Prisma.StringWithAggregatesFilter<"Marriage"> | string
  husbandId?: Prisma.StringWithAggregatesFilter<"Marriage"> | string
  wifeId?: Prisma.StringWithAggregatesFilter<"Marriage"> | string
  marriageDate?: Prisma.DateTimeNullableWithAggregatesFilter<"Marriage"> | Date | string | null
  divorceDate?: Prisma.DateTimeNullableWithAggregatesFilter<"Marriage"> | Date | string | null
  isActive?: Prisma.BoolWithAggregatesFilter<"Marriage"> | boolean
  marriageOrder?: Prisma.IntWithAggregatesFilter<"Marriage"> | number
  createdAt?: Prisma.DateTimeWithAggregatesFilter<"Marriage"> | Date | string
}

export type MarriageCreateInput = {
  id?: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
  husband: Prisma.MemberCreateNestedOneWithoutMarriagesAsHusbandInput
  wife: Prisma.MemberCreateNestedOneWithoutMarriagesAsWifeInput
}

export type MarriageUncheckedCreateInput = {
  id?: string
  husbandId: string
  wifeId: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
}

export type MarriageUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  husband?: Prisma.MemberUpdateOneRequiredWithoutMarriagesAsHusbandNestedInput
  wife?: Prisma.MemberUpdateOneRequiredWithoutMarriagesAsWifeNestedInput
}

export type MarriageUncheckedUpdateInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  husbandId?: Prisma.StringFieldUpdateOperationsInput | string
  wifeId?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarriageCreateManyInput = {
  id?: string
  husbandId: string
  wifeId: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
}

export type MarriageUpdateManyMutationInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarriageUncheckedUpdateManyInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  husbandId?: Prisma.StringFieldUpdateOperationsInput | string
  wifeId?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarriageListRelationFilter = {
  every?: Prisma.MarriageWhereInput
  some?: Prisma.MarriageWhereInput
  none?: Prisma.MarriageWhereInput
}

export type MarriageOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type MarriageOrderByRelevanceInput = {
  fields: Prisma.MarriageOrderByRelevanceFieldEnum | Prisma.MarriageOrderByRelevanceFieldEnum[]
  sort: Prisma.SortOrder
  search: string
}

export type MarriageCountOrderByAggregateInput = {
  id?: Prisma.SortOrder
  husbandId?: Prisma.SortOrder
  wifeId?: Prisma.SortOrder
  marriageDate?: Prisma.SortOrder
  divorceDate?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  marriageOrder?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type MarriageAvgOrderByAggregateInput = {
  marriageOrder?: Prisma.SortOrder
}

export type MarriageMaxOrderByAggregateInput = {
  id?: Prisma.SortOrder
  husbandId?: Prisma.SortOrder
  wifeId?: Prisma.SortOrder
  marriageDate?: Prisma.SortOrder
  divorceDate?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  marriageOrder?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type MarriageMinOrderByAggregateInput = {
  id?: Prisma.SortOrder
  husbandId?: Prisma.SortOrder
  wifeId?: Prisma.SortOrder
  marriageDate?: Prisma.SortOrder
  divorceDate?: Prisma.SortOrder
  isActive?: Prisma.SortOrder
  marriageOrder?: Prisma.SortOrder
  createdAt?: Prisma.SortOrder
}

export type MarriageSumOrderByAggregateInput = {
  marriageOrder?: Prisma.SortOrder
}

export type MarriageCreateNestedManyWithoutHusbandInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutHusbandInput, Prisma.MarriageUncheckedCreateWithoutHusbandInput> | Prisma.MarriageCreateWithoutHusbandInput[] | Prisma.MarriageUncheckedCreateWithoutHusbandInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutHusbandInput | Prisma.MarriageCreateOrConnectWithoutHusbandInput[]
  createMany?: Prisma.MarriageCreateManyHusbandInputEnvelope
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
}

export type MarriageCreateNestedManyWithoutWifeInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutWifeInput, Prisma.MarriageUncheckedCreateWithoutWifeInput> | Prisma.MarriageCreateWithoutWifeInput[] | Prisma.MarriageUncheckedCreateWithoutWifeInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutWifeInput | Prisma.MarriageCreateOrConnectWithoutWifeInput[]
  createMany?: Prisma.MarriageCreateManyWifeInputEnvelope
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
}

export type MarriageUncheckedCreateNestedManyWithoutHusbandInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutHusbandInput, Prisma.MarriageUncheckedCreateWithoutHusbandInput> | Prisma.MarriageCreateWithoutHusbandInput[] | Prisma.MarriageUncheckedCreateWithoutHusbandInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutHusbandInput | Prisma.MarriageCreateOrConnectWithoutHusbandInput[]
  createMany?: Prisma.MarriageCreateManyHusbandInputEnvelope
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
}

export type MarriageUncheckedCreateNestedManyWithoutWifeInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutWifeInput, Prisma.MarriageUncheckedCreateWithoutWifeInput> | Prisma.MarriageCreateWithoutWifeInput[] | Prisma.MarriageUncheckedCreateWithoutWifeInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutWifeInput | Prisma.MarriageCreateOrConnectWithoutWifeInput[]
  createMany?: Prisma.MarriageCreateManyWifeInputEnvelope
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
}

export type MarriageUpdateManyWithoutHusbandNestedInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutHusbandInput, Prisma.MarriageUncheckedCreateWithoutHusbandInput> | Prisma.MarriageCreateWithoutHusbandInput[] | Prisma.MarriageUncheckedCreateWithoutHusbandInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutHusbandInput | Prisma.MarriageCreateOrConnectWithoutHusbandInput[]
  upsert?: Prisma.MarriageUpsertWithWhereUniqueWithoutHusbandInput | Prisma.MarriageUpsertWithWhereUniqueWithoutHusbandInput[]
  createMany?: Prisma.MarriageCreateManyHusbandInputEnvelope
  set?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  disconnect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  delete?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  update?: Prisma.MarriageUpdateWithWhereUniqueWithoutHusbandInput | Prisma.MarriageUpdateWithWhereUniqueWithoutHusbandInput[]
  updateMany?: Prisma.MarriageUpdateManyWithWhereWithoutHusbandInput | Prisma.MarriageUpdateManyWithWhereWithoutHusbandInput[]
  deleteMany?: Prisma.MarriageScalarWhereInput | Prisma.MarriageScalarWhereInput[]
}

export type MarriageUpdateManyWithoutWifeNestedInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutWifeInput, Prisma.MarriageUncheckedCreateWithoutWifeInput> | Prisma.MarriageCreateWithoutWifeInput[] | Prisma.MarriageUncheckedCreateWithoutWifeInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutWifeInput | Prisma.MarriageCreateOrConnectWithoutWifeInput[]
  upsert?: Prisma.MarriageUpsertWithWhereUniqueWithoutWifeInput | Prisma.MarriageUpsertWithWhereUniqueWithoutWifeInput[]
  createMany?: Prisma.MarriageCreateManyWifeInputEnvelope
  set?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  disconnect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  delete?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  update?: Prisma.MarriageUpdateWithWhereUniqueWithoutWifeInput | Prisma.MarriageUpdateWithWhereUniqueWithoutWifeInput[]
  updateMany?: Prisma.MarriageUpdateManyWithWhereWithoutWifeInput | Prisma.MarriageUpdateManyWithWhereWithoutWifeInput[]
  deleteMany?: Prisma.MarriageScalarWhereInput | Prisma.MarriageScalarWhereInput[]
}

export type MarriageUncheckedUpdateManyWithoutHusbandNestedInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutHusbandInput, Prisma.MarriageUncheckedCreateWithoutHusbandInput> | Prisma.MarriageCreateWithoutHusbandInput[] | Prisma.MarriageUncheckedCreateWithoutHusbandInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutHusbandInput | Prisma.MarriageCreateOrConnectWithoutHusbandInput[]
  upsert?: Prisma.MarriageUpsertWithWhereUniqueWithoutHusbandInput | Prisma.MarriageUpsertWithWhereUniqueWithoutHusbandInput[]
  createMany?: Prisma.MarriageCreateManyHusbandInputEnvelope
  set?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  disconnect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  delete?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  update?: Prisma.MarriageUpdateWithWhereUniqueWithoutHusbandInput | Prisma.MarriageUpdateWithWhereUniqueWithoutHusbandInput[]
  updateMany?: Prisma.MarriageUpdateManyWithWhereWithoutHusbandInput | Prisma.MarriageUpdateManyWithWhereWithoutHusbandInput[]
  deleteMany?: Prisma.MarriageScalarWhereInput | Prisma.MarriageScalarWhereInput[]
}

export type MarriageUncheckedUpdateManyWithoutWifeNestedInput = {
  create?: Prisma.XOR<Prisma.MarriageCreateWithoutWifeInput, Prisma.MarriageUncheckedCreateWithoutWifeInput> | Prisma.MarriageCreateWithoutWifeInput[] | Prisma.MarriageUncheckedCreateWithoutWifeInput[]
  connectOrCreate?: Prisma.MarriageCreateOrConnectWithoutWifeInput | Prisma.MarriageCreateOrConnectWithoutWifeInput[]
  upsert?: Prisma.MarriageUpsertWithWhereUniqueWithoutWifeInput | Prisma.MarriageUpsertWithWhereUniqueWithoutWifeInput[]
  createMany?: Prisma.MarriageCreateManyWifeInputEnvelope
  set?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  disconnect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  delete?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  connect?: Prisma.MarriageWhereUniqueInput | Prisma.MarriageWhereUniqueInput[]
  update?: Prisma.MarriageUpdateWithWhereUniqueWithoutWifeInput | Prisma.MarriageUpdateWithWhereUniqueWithoutWifeInput[]
  updateMany?: Prisma.MarriageUpdateManyWithWhereWithoutWifeInput | Prisma.MarriageUpdateManyWithWhereWithoutWifeInput[]
  deleteMany?: Prisma.MarriageScalarWhereInput | Prisma.MarriageScalarWhereInput[]
}

export type MarriageCreateWithoutHusbandInput = {
  id?: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
  wife: Prisma.MemberCreateNestedOneWithoutMarriagesAsWifeInput
}

export type MarriageUncheckedCreateWithoutHusbandInput = {
  id?: string
  wifeId: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
}

export type MarriageCreateOrConnectWithoutHusbandInput = {
  where: Prisma.MarriageWhereUniqueInput
  create: Prisma.XOR<Prisma.MarriageCreateWithoutHusbandInput, Prisma.MarriageUncheckedCreateWithoutHusbandInput>
}

export type MarriageCreateManyHusbandInputEnvelope = {
  data: Prisma.MarriageCreateManyHusbandInput | Prisma.MarriageCreateManyHusbandInput[]
  skipDuplicates?: boolean
}

export type MarriageCreateWithoutWifeInput = {
  id?: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
  husband: Prisma.MemberCreateNestedOneWithoutMarriagesAsHusbandInput
}

export type MarriageUncheckedCreateWithoutWifeInput = {
  id?: string
  husbandId: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
}

export type MarriageCreateOrConnectWithoutWifeInput = {
  where: Prisma.MarriageWhereUniqueInput
  create: Prisma.XOR<Prisma.MarriageCreateWithoutWifeInput, Prisma.MarriageUncheckedCreateWithoutWifeInput>
}

export type MarriageCreateManyWifeInputEnvelope = {
  data: Prisma.MarriageCreateManyWifeInput | Prisma.MarriageCreateManyWifeInput[]
  skipDuplicates?: boolean
}

export type MarriageUpsertWithWhereUniqueWithoutHusbandInput = {
  where: Prisma.MarriageWhereUniqueInput
  update: Prisma.XOR<Prisma.MarriageUpdateWithoutHusbandInput, Prisma.MarriageUncheckedUpdateWithoutHusbandInput>
  create: Prisma.XOR<Prisma.MarriageCreateWithoutHusbandInput, Prisma.MarriageUncheckedCreateWithoutHusbandInput>
}

export type MarriageUpdateWithWhereUniqueWithoutHusbandInput = {
  where: Prisma.MarriageWhereUniqueInput
  data: Prisma.XOR<Prisma.MarriageUpdateWithoutHusbandInput, Prisma.MarriageUncheckedUpdateWithoutHusbandInput>
}

export type MarriageUpdateManyWithWhereWithoutHusbandInput = {
  where: Prisma.MarriageScalarWhereInput
  data: Prisma.XOR<Prisma.MarriageUpdateManyMutationInput, Prisma.MarriageUncheckedUpdateManyWithoutHusbandInput>
}

export type MarriageScalarWhereInput = {
  AND?: Prisma.MarriageScalarWhereInput | Prisma.MarriageScalarWhereInput[]
  OR?: Prisma.MarriageScalarWhereInput[]
  NOT?: Prisma.MarriageScalarWhereInput | Prisma.MarriageScalarWhereInput[]
  id?: Prisma.StringFilter<"Marriage"> | string
  husbandId?: Prisma.StringFilter<"Marriage"> | string
  wifeId?: Prisma.StringFilter<"Marriage"> | string
  marriageDate?: Prisma.DateTimeNullableFilter<"Marriage"> | Date | string | null
  divorceDate?: Prisma.DateTimeNullableFilter<"Marriage"> | Date | string | null
  isActive?: Prisma.BoolFilter<"Marriage"> | boolean
  marriageOrder?: Prisma.IntFilter<"Marriage"> | number
  createdAt?: Prisma.DateTimeFilter<"Marriage"> | Date | string
}

export type MarriageUpsertWithWhereUniqueWithoutWifeInput = {
  where: Prisma.MarriageWhereUniqueInput
  update: Prisma.XOR<Prisma.MarriageUpdateWithoutWifeInput, Prisma.MarriageUncheckedUpdateWithoutWifeInput>
  create: Prisma.XOR<Prisma.MarriageCreateWithoutWifeInput, Prisma.MarriageUncheckedCreateWithoutWifeInput>
}

export type MarriageUpdateWithWhereUniqueWithoutWifeInput = {
  where: Prisma.MarriageWhereUniqueInput
  data: Prisma.XOR<Prisma.MarriageUpdateWithoutWifeInput, Prisma.MarriageUncheckedUpdateWithoutWifeInput>
}

export type MarriageUpdateManyWithWhereWithoutWifeInput = {
  where: Prisma.MarriageScalarWhereInput
  data: Prisma.XOR<Prisma.MarriageUpdateManyMutationInput, Prisma.MarriageUncheckedUpdateManyWithoutWifeInput>
}

export type MarriageCreateManyHusbandInput = {
  id?: string
  wifeId: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
}

export type MarriageCreateManyWifeInput = {
  id?: string
  husbandId: string
  marriageDate?: Date | string | null
  divorceDate?: Date | string | null
  isActive?: boolean
  marriageOrder?: number
  createdAt?: Date | string
}

export type MarriageUpdateWithoutHusbandInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  wife?: Prisma.MemberUpdateOneRequiredWithoutMarriagesAsWifeNestedInput
}

export type MarriageUncheckedUpdateWithoutHusbandInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  wifeId?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarriageUncheckedUpdateManyWithoutHusbandInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  wifeId?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarriageUpdateWithoutWifeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
  husband?: Prisma.MemberUpdateOneRequiredWithoutMarriagesAsHusbandNestedInput
}

export type MarriageUncheckedUpdateWithoutWifeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  husbandId?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}

export type MarriageUncheckedUpdateManyWithoutWifeInput = {
  id?: Prisma.StringFieldUpdateOperationsInput | string
  husbandId?: Prisma.StringFieldUpdateOperationsInput | string
  marriageDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  divorceDate?: Prisma.NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  isActive?: Prisma.BoolFieldUpdateOperationsInput | boolean
  marriageOrder?: Prisma.IntFieldUpdateOperationsInput | number
  createdAt?: Prisma.DateTimeFieldUpdateOperationsInput | Date | string
}



export type MarriageSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  id?: boolean
  husbandId?: boolean
  wifeId?: boolean
  marriageDate?: boolean
  divorceDate?: boolean
  isActive?: boolean
  marriageOrder?: boolean
  createdAt?: boolean
  husband?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  wife?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
}, ExtArgs["result"]["marriage"]>



export type MarriageSelectScalar = {
  id?: boolean
  husbandId?: boolean
  wifeId?: boolean
  marriageDate?: boolean
  divorceDate?: boolean
  isActive?: boolean
  marriageOrder?: boolean
  createdAt?: boolean
}

export type MarriageOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"id" | "husbandId" | "wifeId" | "marriageDate" | "divorceDate" | "isActive" | "marriageOrder" | "createdAt", ExtArgs["result"]["marriage"]>
export type MarriageInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  husband?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
  wife?: boolean | Prisma.MemberDefaultArgs<ExtArgs>
}

export type $MarriagePayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "Marriage"
  objects: {
    husband: Prisma.$MemberPayload<ExtArgs>
    wife: Prisma.$MemberPayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    id: string
    husbandId: string
    wifeId: string
    marriageDate: Date | null
    divorceDate: Date | null
    isActive: boolean
    marriageOrder: number
    createdAt: Date
  }, ExtArgs["result"]["marriage"]>
  composites: {}
}

export type MarriageGetPayload<S extends boolean | null | undefined | MarriageDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$MarriagePayload, S>

export type MarriageCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<MarriageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: MarriageCountAggregateInputType | true
  }

export interface MarriageDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Marriage'], meta: { name: 'Marriage' } }
  /**
   * Find zero or one Marriage that matches the filter.
   * @param {MarriageFindUniqueArgs} args - Arguments to find a Marriage
   * @example
   * // Get one Marriage
   * const marriage = await prisma.marriage.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends MarriageFindUniqueArgs>(args: Prisma.SelectSubset<T, MarriageFindUniqueArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one Marriage that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {MarriageFindUniqueOrThrowArgs} args - Arguments to find a Marriage
   * @example
   * // Get one Marriage
   * const marriage = await prisma.marriage.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends MarriageFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, MarriageFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Marriage that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarriageFindFirstArgs} args - Arguments to find a Marriage
   * @example
   * // Get one Marriage
   * const marriage = await prisma.marriage.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends MarriageFindFirstArgs>(args?: Prisma.SelectSubset<T, MarriageFindFirstArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first Marriage that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarriageFindFirstOrThrowArgs} args - Arguments to find a Marriage
   * @example
   * // Get one Marriage
   * const marriage = await prisma.marriage.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends MarriageFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, MarriageFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more Marriages that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarriageFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all Marriages
   * const marriages = await prisma.marriage.findMany()
   * 
   * // Get first 10 Marriages
   * const marriages = await prisma.marriage.findMany({ take: 10 })
   * 
   * // Only select the `id`
   * const marriageWithIdOnly = await prisma.marriage.findMany({ select: { id: true } })
   * 
   */
  findMany<T extends MarriageFindManyArgs>(args?: Prisma.SelectSubset<T, MarriageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a Marriage.
   * @param {MarriageCreateArgs} args - Arguments to create a Marriage.
   * @example
   * // Create one Marriage
   * const Marriage = await prisma.marriage.create({
   *   data: {
   *     // ... data to create a Marriage
   *   }
   * })
   * 
   */
  create<T extends MarriageCreateArgs>(args: Prisma.SelectSubset<T, MarriageCreateArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many Marriages.
   * @param {MarriageCreateManyArgs} args - Arguments to create many Marriages.
   * @example
   * // Create many Marriages
   * const marriage = await prisma.marriage.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends MarriageCreateManyArgs>(args?: Prisma.SelectSubset<T, MarriageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Delete a Marriage.
   * @param {MarriageDeleteArgs} args - Arguments to delete one Marriage.
   * @example
   * // Delete one Marriage
   * const Marriage = await prisma.marriage.delete({
   *   where: {
   *     // ... filter to delete one Marriage
   *   }
   * })
   * 
   */
  delete<T extends MarriageDeleteArgs>(args: Prisma.SelectSubset<T, MarriageDeleteArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one Marriage.
   * @param {MarriageUpdateArgs} args - Arguments to update one Marriage.
   * @example
   * // Update one Marriage
   * const marriage = await prisma.marriage.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends MarriageUpdateArgs>(args: Prisma.SelectSubset<T, MarriageUpdateArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more Marriages.
   * @param {MarriageDeleteManyArgs} args - Arguments to filter Marriages to delete.
   * @example
   * // Delete a few Marriages
   * const { count } = await prisma.marriage.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends MarriageDeleteManyArgs>(args?: Prisma.SelectSubset<T, MarriageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more Marriages.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarriageUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many Marriages
   * const marriage = await prisma.marriage.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends MarriageUpdateManyArgs>(args: Prisma.SelectSubset<T, MarriageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create or update one Marriage.
   * @param {MarriageUpsertArgs} args - Arguments to update or create a Marriage.
   * @example
   * // Update or create a Marriage
   * const marriage = await prisma.marriage.upsert({
   *   create: {
   *     // ... data to create a Marriage
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the Marriage we want to update
   *   }
   * })
   */
  upsert<T extends MarriageUpsertArgs>(args: Prisma.SelectSubset<T, MarriageUpsertArgs<ExtArgs>>): Prisma.Prisma__MarriageClient<runtime.Types.Result.GetResult<Prisma.$MarriagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of Marriages.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarriageCountArgs} args - Arguments to filter Marriages to count.
   * @example
   * // Count the number of Marriages
   * const count = await prisma.marriage.count({
   *   where: {
   *     // ... the filter for the Marriages we want to count
   *   }
   * })
  **/
  count<T extends MarriageCountArgs>(
    args?: Prisma.Subset<T, MarriageCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], MarriageCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a Marriage.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarriageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends MarriageAggregateArgs>(args: Prisma.Subset<T, MarriageAggregateArgs>): Prisma.PrismaPromise<GetMarriageAggregateType<T>>

  /**
   * Group by Marriage.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {MarriageGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends MarriageGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: MarriageGroupByArgs['orderBy'] }
      : { orderBy?: MarriageGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, MarriageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMarriageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the Marriage model
 */
readonly fields: MarriageFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for Marriage.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__MarriageClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  husband<T extends Prisma.MemberDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MemberDefaultArgs<ExtArgs>>): Prisma.Prisma__MemberClient<runtime.Types.Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  wife<T extends Prisma.MemberDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.MemberDefaultArgs<ExtArgs>>): Prisma.Prisma__MemberClient<runtime.Types.Result.GetResult<Prisma.$MemberPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the Marriage model
 */
export interface MarriageFieldRefs {
  readonly id: Prisma.FieldRef<"Marriage", 'String'>
  readonly husbandId: Prisma.FieldRef<"Marriage", 'String'>
  readonly wifeId: Prisma.FieldRef<"Marriage", 'String'>
  readonly marriageDate: Prisma.FieldRef<"Marriage", 'DateTime'>
  readonly divorceDate: Prisma.FieldRef<"Marriage", 'DateTime'>
  readonly isActive: Prisma.FieldRef<"Marriage", 'Boolean'>
  readonly marriageOrder: Prisma.FieldRef<"Marriage", 'Int'>
  readonly createdAt: Prisma.FieldRef<"Marriage", 'DateTime'>
}
    

// Custom InputTypes
/**
 * Marriage findUnique
 */
export type MarriageFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * Filter, which Marriage to fetch.
   */
  where: Prisma.MarriageWhereUniqueInput
}

/**
 * Marriage findUniqueOrThrow
 */
export type MarriageFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * Filter, which Marriage to fetch.
   */
  where: Prisma.MarriageWhereUniqueInput
}

/**
 * Marriage findFirst
 */
export type MarriageFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * Filter, which Marriage to fetch.
   */
  where?: Prisma.MarriageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Marriages to fetch.
   */
  orderBy?: Prisma.MarriageOrderByWithRelationInput | Prisma.MarriageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Marriages.
   */
  cursor?: Prisma.MarriageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Marriages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Marriages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Marriages.
   */
  distinct?: Prisma.MarriageScalarFieldEnum | Prisma.MarriageScalarFieldEnum[]
}

/**
 * Marriage findFirstOrThrow
 */
export type MarriageFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * Filter, which Marriage to fetch.
   */
  where?: Prisma.MarriageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Marriages to fetch.
   */
  orderBy?: Prisma.MarriageOrderByWithRelationInput | Prisma.MarriageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for Marriages.
   */
  cursor?: Prisma.MarriageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Marriages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Marriages.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of Marriages.
   */
  distinct?: Prisma.MarriageScalarFieldEnum | Prisma.MarriageScalarFieldEnum[]
}

/**
 * Marriage findMany
 */
export type MarriageFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * Filter, which Marriages to fetch.
   */
  where?: Prisma.MarriageWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of Marriages to fetch.
   */
  orderBy?: Prisma.MarriageOrderByWithRelationInput | Prisma.MarriageOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing Marriages.
   */
  cursor?: Prisma.MarriageWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` Marriages from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` Marriages.
   */
  skip?: number
  distinct?: Prisma.MarriageScalarFieldEnum | Prisma.MarriageScalarFieldEnum[]
}

/**
 * Marriage create
 */
export type MarriageCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * The data needed to create a Marriage.
   */
  data: Prisma.XOR<Prisma.MarriageCreateInput, Prisma.MarriageUncheckedCreateInput>
}

/**
 * Marriage createMany
 */
export type MarriageCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many Marriages.
   */
  data: Prisma.MarriageCreateManyInput | Prisma.MarriageCreateManyInput[]
  skipDuplicates?: boolean
}

/**
 * Marriage update
 */
export type MarriageUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * The data needed to update a Marriage.
   */
  data: Prisma.XOR<Prisma.MarriageUpdateInput, Prisma.MarriageUncheckedUpdateInput>
  /**
   * Choose, which Marriage to update.
   */
  where: Prisma.MarriageWhereUniqueInput
}

/**
 * Marriage updateMany
 */
export type MarriageUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update Marriages.
   */
  data: Prisma.XOR<Prisma.MarriageUpdateManyMutationInput, Prisma.MarriageUncheckedUpdateManyInput>
  /**
   * Filter which Marriages to update
   */
  where?: Prisma.MarriageWhereInput
  /**
   * Limit how many Marriages to update.
   */
  limit?: number
}

/**
 * Marriage upsert
 */
export type MarriageUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * The filter to search for the Marriage to update in case it exists.
   */
  where: Prisma.MarriageWhereUniqueInput
  /**
   * In case the Marriage found by the `where` argument doesn't exist, create a new Marriage with this data.
   */
  create: Prisma.XOR<Prisma.MarriageCreateInput, Prisma.MarriageUncheckedCreateInput>
  /**
   * In case the Marriage was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.MarriageUpdateInput, Prisma.MarriageUncheckedUpdateInput>
}

/**
 * Marriage delete
 */
export type MarriageDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
  /**
   * Filter which Marriage to delete.
   */
  where: Prisma.MarriageWhereUniqueInput
}

/**
 * Marriage deleteMany
 */
export type MarriageDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which Marriages to delete
   */
  where?: Prisma.MarriageWhereInput
  /**
   * Limit how many Marriages to delete.
   */
  limit?: number
}

/**
 * Marriage without action
 */
export type MarriageDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the Marriage
   */
  select?: Prisma.MarriageSelect<ExtArgs> | null
  /**
   * Omit specific fields from the Marriage
   */
  omit?: Prisma.MarriageOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.MarriageInclude<ExtArgs> | null
}
